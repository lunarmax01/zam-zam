import {
  require_react
} from "./chunk-EFTEWGEA.js";
import {
  __toESM
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@react-hook/mouse-position/dist/module/index.js
var React4 = __toESM(require_react());

// node_modules/@react-hook/event/dist/module/index.js
var React = __toESM(require_react());
function useEvent(target, type, listener, cleanup) {
  const storedListener = React.useRef(listener);
  const storedCleanup = React.useRef(cleanup);
  React.useEffect(() => {
    storedListener.current = listener;
    storedCleanup.current = cleanup;
  });
  React.useEffect(() => {
    const targetEl = target && "current" in target ? target.current : target;
    if (!targetEl) return;
    let didUnsubscribe = 0;
    function listener2(...args) {
      if (didUnsubscribe) return;
      storedListener.current.apply(this, args);
    }
    targetEl.addEventListener(type, listener2);
    const cleanup2 = storedCleanup.current;
    return () => {
      didUnsubscribe = 1;
      targetEl.removeEventListener(type, listener2);
      cleanup2 && cleanup2();
    };
  }, [target, type]);
}
var module_default = useEvent;

// node_modules/@react-hook/throttle/dist/module/index.js
var React3 = __toESM(require_react());

// node_modules/@react-hook/latest/dist/module/index.js
var React2 = __toESM(require_react());
var useLatest = (current) => {
  const storedValue = React2.useRef(current);
  React2.useEffect(() => {
    storedValue.current = current;
  });
  return storedValue;
};
var module_default2 = useLatest;

// node_modules/@react-hook/throttle/dist/module/index.js
var perf = typeof performance !== "undefined" ? performance : Date;
var now = () => perf.now();
function useThrottleCallback(callback, fps = 30, leading = false) {
  const storedCallback = module_default2(callback);
  const ms = 1e3 / fps;
  const prev = React3.useRef(0);
  const trailingTimeout = React3.useRef();
  const clearTrailing = () => trailingTimeout.current && clearTimeout(trailingTimeout.current);
  const deps = [fps, leading, storedCallback];
  function _ref3() {
    prev.current = 0;
    clearTrailing();
  }
  React3.useEffect(() => _ref3, deps);
  return React3.useCallback(function() {
    const args = arguments;
    const rightNow = now();
    const call = () => {
      prev.current = rightNow;
      clearTrailing();
      storedCallback.current.apply(null, args);
    };
    const current = prev.current;
    if (leading && current === 0) return call();
    if (rightNow - current > ms) {
      if (current > 0) return call();
      prev.current = rightNow;
    }
    clearTrailing();
    trailingTimeout.current = setTimeout(() => {
      call();
      prev.current = 0;
    }, ms);
  }, deps);
}

// node_modules/@react-hook/mouse-position/dist/module/index.js
function _ref(state, action) {
  if (typeof window === "undefined") return state;
  const {
    event: e,
    element
  } = action;
  let event;
  if ("touches" in e) {
    event = e.touches[0];
  } else {
    event = e;
  }
  const {
    clientX,
    clientY,
    screenX,
    screenY,
    pageX = 0,
    pageY = 0
  } = event;
  const rect = element.getBoundingClientRect();
  const x = pageX - rect.left - (window.pageXOffset || window.scrollX);
  const y = pageY - rect.top - (window.pageYOffset || window.scrollY);
  if ("touches" in e && (x < 0 || y < 0 || x > rect.width || y > rect.height)) {
    return {
      ...state,
      context: {
        ...state.context,
        hoverStatus: "leave",
        touchStatus: "end"
      }
    };
  }
  return {
    context: {
      ...state.context,
      hoverStatus: "enter"
    },
    mouse: {
      ...state.mouse,
      x,
      y,
      pageX,
      pageY,
      clientX,
      clientY,
      screenX,
      screenY,
      elementWidth: rect.width,
      elementHeight: rect.height,
      isOver: true,
      isTouch: "touches" in e
    }
  };
}
function _ref2(state, action) {
  const {
    mouse,
    context
  } = state;
  const handleDown = _ref;
  if (action.type === "mousemove") {
    if (context.touchStatus === "end") return state;
    return handleDown(state, action);
  } else if (action.type === "touchmove") {
    const nextState = {
      context: {
        ...context,
        touchStatus: "start"
      },
      mouse
    };
    return handleDown(nextState, action);
  } else if (action.type === "touchdown") {
    const nextState = {
      context: {
        ...context,
        touchStatus: "start"
      },
      mouse: {
        ...mouse,
        isDown: true
      }
    };
    return handleDown(nextState, action);
  } else if (action.type === "mousedown") {
    return {
      context,
      mouse: {
        ...mouse,
        isDown: true
      }
    };
  } else if (action.type === "mouseup") {
    return {
      context,
      mouse: {
        ...mouse,
        isDown: false
      }
    };
  } else if (action.type === "mouseleave") {
    return {
      context: {
        ...context,
        hoverStatus: "leave"
      },
      mouse: {
        ...mouse,
        isOver: false
      }
    };
  } else if (action.type === "touchleave") {
    return {
      context: {
        ...context,
        hoverStatus: "leave",
        touchStatus: "end"
      },
      mouse: {
        ...mouse,
        isOver: false,
        isDown: false
      }
    };
  } else if (action.type === "activeStatus") {
    return {
      context: {
        ...context,
        activeStatus: action.value
      },
      mouse
    };
  }
  return state;
}
function useMouse(target, options = {}) {
  const {
    fps = 30,
    enterDelay = 0,
    leaveDelay = 0
  } = options;
  const [state, dispatch] = React4.useReducer(_ref2, {
    mouse: initialState,
    context: initialContext
  });
  const onMove = useThrottleCallback((event) => {
    const element = target && "current" in target ? target.current : target;
    if (!element) return;
    dispatch({
      type: "mousemove",
      event,
      element
    });
  }, fps, true);
  const onTouchMove = useThrottleCallback((event) => {
    const element = target && "current" in target ? target.current : target;
    if (!element) return;
    dispatch({
      type: "touchmove",
      event,
      element
    });
  }, fps, true);
  const onLeave = useThrottleCallback(
    () => dispatch({
      type: "mouseleave"
    }),
    fps,
    // This has to be false because we always want this callback to fire after any
    // move events.
    false
  );
  const onDown = useThrottleCallback((event) => {
    const element = target && "current" in target ? target.current : target;
    if (!element) return;
    dispatch("touches" in event ? {
      type: "touchdown",
      element,
      event
    } : {
      type: "mousedown",
      element,
      event
    });
  }, fps, true);
  const onUp = useThrottleCallback(
    () => dispatch({
      type: "mouseup"
    }),
    fps,
    // This has to be false because we always want this callback to fire after any
    // down events.
    false
  );
  const onTouchEnd = useThrottleCallback(
    () => dispatch({
      type: "touchleave"
    }),
    fps,
    // This has to be false because we always want this callback to fire after any
    // move events.
    false
  );
  module_default(target, "mouseenter", onMove);
  module_default(target, "mousemove", onMove);
  module_default(target, "mouseleave", onLeave);
  module_default(target, "mousedown", onDown);
  module_default(typeof window !== "undefined" ? window : null, "mousedown", onDown);
  module_default(typeof window !== "undefined" ? window : null, "mouseup", onUp);
  module_default(target, "touchstart", onDown);
  module_default(target, "touchmove", onTouchMove);
  module_default(target, "touchend", onTouchEnd);
  module_default(target, "touchcancel", onTouchEnd);
  function _ref3() {
    return dispatch({
      type: "activeStatus",
      value: "active"
    });
  }
  function _ref4() {
    return dispatch({
      type: "activeStatus",
      value: "inactive"
    });
  }
  React4.useEffect(() => {
    if (state.context.hoverStatus === "enter") {
      if (enterDelay) {
        const timeout = setTimeout(_ref3, enterDelay);
        return () => clearTimeout(timeout);
      }
      dispatch({
        type: "activeStatus",
        value: "active"
      });
    } else {
      if (leaveDelay) {
        const timeout = setTimeout(_ref4, leaveDelay);
        return () => clearTimeout(timeout);
      }
      dispatch({
        type: "activeStatus",
        value: "inactive"
      });
    }
  }, [state.context.hoverStatus, enterDelay, leaveDelay]);
  return state.context.activeStatus === "active" ? state.mouse : initialState;
}
var initialState = {
  x: null,
  y: null,
  pageX: null,
  pageY: null,
  clientX: null,
  clientY: null,
  screenX: null,
  screenY: null,
  elementWidth: null,
  elementHeight: null,
  isOver: false,
  isDown: false,
  isTouch: false
};
var initialContext = {
  hoverStatus: "idle",
  touchStatus: "idle",
  activeStatus: "inactive"
};
var module_default3 = useMouse;
export {
  module_default3 as default
};
//# sourceMappingURL=@react-hook_mouse-position.js.map
